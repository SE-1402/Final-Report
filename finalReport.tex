%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Example: Project Report
%
% Source: http://www.howtotex.com
%
% Feel free to distribute this example, but please keep the referral
% to howtotex.com
% Date: March 2011 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% How to use writeLaTeX: 
%
% You edit the source code here on the left, and the preview on the
% right shows you the result within a few seconds.
%
% Bookmark this page and share the URL with your co-authors. They can
% edit at the same time!
%
% You can upload figures, bibliographies, custom classes and
% styles using the files menu.
%
% If you're new to LaTeX, the wikibook is a great place to start:
% http://en.wikibooks.org/wiki/LaTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Edit the title below to update the display in My Documents
%\title{Project Report}
%
%%% Preamble
\documentclass[paper=a4, fontsize=11pt]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage{fourier}

\usepackage[english]{babel}															% English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}	
\usepackage{url}

\usepackage{color}
\usepackage{multicol}
\setlength{\columnsep}{1cm}
\usepackage{graphicx}
\graphicspath{{images/}}
\setlength\parindent{0pt}
\usepackage{array}

%%% Custom sectioning
\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}											% No page header
\fancyfoot[L]{}											% Empty 
\fancyfoot[C]{}											% Empty
\fancyfoot[R]{\thepage}									% Pagenumbering
\renewcommand{\headrulewidth}{0pt}			% Remove header underlines
\renewcommand{\footrulewidth}{0pt}				% Remove footer underlines
\setlength{\headheight}{13.6pt}


%%% Equation and float numbering
\numberwithin{equation}{section}		% Equationnumbering: section.eq#
\numberwithin{figure}{section}			% Figurenumbering: section.fig#
\numberwithin{table}{section}				% Tablenumbering: section.tab#


%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	% Horizontal rule
\definecolor{darkgreen}{RGB}{0,153,76}

\title{
		\vspace{1in} 	
		\usefont{OT1}{bch}{b}{n}
		\normalfont \normalsize \textsc{Iowa State University} \\ [25pt]
		{\color{darkgreen}\horrule{1pt} \\[0.5cm]}
		\huge CANdroid \\
		{\color{darkgreen}\horrule{1pt} \\[0.5cm]}
		\vspace{1.25in}
}

\author{
		\normalfont 								\normalsize
		{\color{darkgreen} Group Dec 14-02}\\ \normalsize
        Alec Johanson\\[-3pt]		\normalsize
        John Shelley\\[-3pt]		\normalsize
        Ahmmad Shelley\\[-3pt]		\normalsize
		\\ \normalsize
		{\color{darkgreen} Client}\\ \normalsize
		Vermeer \\ \normalsize
		\\ \normalsize
		{\color{darkgreen} Advisors}\\ \normalsize
		Arun Somani \\ \normalsize
		Koray Celik \\ \normalsize
}
\date{}

%%% Begin document
\begin{document}
\maketitle
\pagebreak
\section{Problem}
Modern off-highway/agricultural systems use outdoor rated LCD displays to implement user interfaces. These current solutions are either too expensive, or put users at risk being an unsafe distance from the machines. Vermeer wishes to replace these expensive display systems with a more inexpensive solution as well as provide a more flexible development environment. A J1939 CAN system is used on most Vermeer systems, but would like to be expandable to other protocols. Vermeer has expressed their wish of emphasizing research and development with solutions utilizing android systems due to their prior experience with this technology. \\
	
\noindent In more layman's terms: Vermeer currently uses a CAN bus to communicate data from a machine, such as a baler, to a VT (Virtual Terminal) in the cab of the tractor that is towing it. These VTs are wired, and proprietary. This makes them expensive and exposes the CAN bus to the harsh Agricultural environment. Replacing the Virtual Terminal with an android device has the potential to greatly reduce cost. While making the connection to the android device wireless can help prevent erosion and weakening of the system. \\

\subsection{Functional Decomposition}
The main communication pertaining to our project is between a VT (virtual terminal) and a controller on the unit (in our target case a 605 baler). The controller communicates to the VT through a CAN bus starting with a series of hand shakes, setting up the initial UI. Then during normal operation, the controller reads data from point to point connections with sensors. The controller analyzes the data and send UI update information through the CAN bus. The connection between the controller and the VT will now be wireless utilizing android instead of a proprietary VT system. \\

\subsection{System Requirements}
\begin {multicols*}{2}
\center{\textbf{Functional}}
\begin{itemize}
	\item Stream > 10\%  CAN bus load at 250Kbps throughput
	\item Withstand outdoor environment
	\item Withstand high vibration environment
	\item less than \$300 unit cost
\end{itemize} 

\columnbreak

\center{\textbf{Non-Functional}}
\begin{itemize}
	\item User friendly for the android operator
	\item Extensible to other CAN protocols
\end{itemize} 
\end{multicols*}
\pagebreak


\section{Solution}
The solution for this problem is to use a PIC32MX795 microcontroller to receive CAN data from the controller on the operating machine. The PIC32 communicates with a WRT Node module that runs a web socket for the Android device to communicate with wirelessly.

\subsection{System Analysis}

\textbf{Controller} \\
The controller is what obtains the information from outside diagnostic tools on the machine. The controller then analyzes this information to determine what updates are needed for the VT. Another function of the controller is to send commands to these peripherals. \\

\textbf{RF Bridge} \\
The RF Bridge is what receives information from the Controller through the CAN Bus. This will then distribute the information over a wifi signal. Since a cloud connection is less feasible due to operating conditions,  an AdHoc similar network approach will take place. \\

Our solution for the RF Bridge was to use a WRT Node, running a version of embedded linux to act as a server for the android device. The WRT Node can not directly receive a CAN signal so a PIC32 microprocessor translates the CAN data to UART for the WRT Node to receive. \\

\textbf{Android Device} \\
The Android device then takes the input from the RF Bridge. The Android tablet will then output the User Interface in order to visualize what the controller is receiving from the diagnostic tools such as hay, corn, or bean harvesters and such. \\

 Details of the modules are expanded upon in the following sections. Shown in Figure 2.1, is a high level block diagram of our solution.  \\
 \begin{figure}[ht]
	 \center\includegraphics[scale=0.36]{rev4.png}
 \caption{High-Level Block Diagram of Solution}
 \end{figure}

\subsection{Hardware Description}
\textbf{PIC32 Microcontroller}  \\
The most important requirement of the microcontroller we selected was that it needed to be able to receive and interpret CAN signals efficiently. The PIC32 family has multiple families, of which, all PIC32MX5xx, PIC32MX6xxx, and PIC327xxx microcontrollers have CAN modules. We selected the PIC32MX795 due to it's increased memory and computing capacity. We wanted to select a microcontroller that was overpowered rather than underpowered due to the time it takes to deliver the microcontrollers. the PIC32MX795 offers 512KB of program memory, 128KB of ram, UART and SPI modules, as well as the CAN modules stated before. This fulfills everything we need from the microcontroller. \\

The microcontroller is responsible for receiving data from the CAN bus and converting that data to UART so the WRT node can understand it. The data sent over the CAN bus will first be a file called an IOP file. This file gives the initial state of the display for the VT/Android Device. After the IOP file is sent, all subsequent data is updates to the display.  \\

The microcontroller is also responsible for communication in the opposite direction. While the machine is running, the Virtual Terminal can send commands to the machine through various buttons on the screen, such as "Dump Bale". The microcontroller receives these commands via UART from the WRT node and sends a corresponding message on the CAN bus to the controller on the baler. \\

\textbf{WRT Node} \\
We didn't start using the WRT Node until late in the development cycle. We had already gone through 3 different hardware revisions and we weren't sure where to go from there. However, the WRT Node was very useful. The WRT Node runs a flavor of embedded linux called OpenWRT, hence the name of the device. OpenWRT was new for most of us, but the basics were pretty simple. The device was limited to the amount of storage it was able to hold, so we ended up mounting a usb drive with approximately 16 GB of storage. This allowed for a larger set of source code for the python program. \\

The Node housed our WebSocket server, written in python. Unlike most RESTful API based web servers, a WebSocket server allows for continuous communication between a server and its clients through the use of sockets. A client, in our case an Android Tablet, can issue a command to the server. If the command is the "Start" command that the server was expecting then they establish a handshake. The two can now freely talk to each other. The benefit of this allows the server to notify the client of an update, without the client needing to refresh itself every time, like most ajax environments. \\

We chose this over the other revisions we had, because of the ease of use, the mobility, and the cost. The cost of the two XBEE wifi modules, was about the same, if not more, and the Node was much easier to work in a language and environment that we were well familiar with. However, in a highly variable environment that most tractors and balers are positioned in, Vermeer may choose to write a 'C' program on the PIC and communicate directly with the XBEE's if they feel it is faster and more efficient. \\

\textbf{Nexus 7} \\
The Nexus 7 is an Android tablet. It is 7 inches, which is about 1 inch smaller than most tablets on the market currently (such as those from Apple, Samsung, and LG). First released in 2012, and updated in 2013, the Nexus 7 is still considered to be of high quality in both hardware and software. Compared to the other tablets on the market the Nexus is the most cost effective choice. If you needed something of higher quality you will have to spend significantly more than the approximate price of \$180.00. These all contributed to our choice and why we went with the Nexus 7. However, with the current release of the Nexus 9, the 7's are no longer being sold on Google's website. Thankfully the Android OS doesn't constrain us to one specific device. \\

The Client software is a pure translation of the Virtual Terminal that most of the current tractors use in their cabs. It is a very low level software system that was originally design for harsh environments. Basic software elements include: input texts, output texts, graphical objects, meters, bar graphs, buttons, and macros that can be associated with any of the aforementioned items. The Android SDK, has a wide array of resources used to convert and translate any of the given Virtual Terminal predefined Software Components into native Android code. In order to do so, we set off first documenting our approach to translating the given components from the Virtual Terminal systems to Android Views (Appendix LABEL APPENDIX HERE).  \\

\textbf{XBee WiFi Modules (XB2B-WFST-001)} \\
The Xbee WiFi modules were not used in the final design. They were originally selected to make an ad-hoc connection between the microcontroller and the android device. We selected this particular model because of the ability to add any size antenna. This would have helped in testing to see what the minimum size antenna for a certain distance would require. Even though the XBees weren't used in the final design. They proved to be a viable secondary option for Vermeer. They also aided in debugging connections on the final design, since we had proven earlier that the connections worked with them. \\

\pagebreak
\subsection{PCB Design}
 \begin{figure}[ht]
	 \center\includegraphics[scale=0.3]{PCB.jpg}
 \caption{Printable Circuit Board Design for Rev. 4}
 \end{figure}

 \subsection{Unit Cost}
 \vspace{10pt}
 \begin{center}
 \begin{tabular}{l c c c}
	 \textbf{Unit} & \textbf{Qty.} & \textbf{Unit Price (\$)} & \textbf{Total Price (\$)} \\ [1ex]
	 PIC32MX795F512L & 1 & 9.87 & 9.87 \\ [1ex]
	 WRT Node & 1 & 25.00 & 25.00 \\ [1ex]
	 MCP2551 & 1 & 1.22 & 1.22 \\ [1ex]
	 Nexus 7 & 1 & 180 & 180 \\ [1ex]
	 Misc. (Capacitors, etc.) & & <10 & <10 \\ [1ex] \cline{4-4}
	 \textbf{Total}&&& \textbf{~226.09} \\ [1ex]
\end{tabular}
\end{center}
 

 \section{Operation Manual}
 \subsection{Microcontroller} 
 The microcontroller should work as soon as it is turned on if the program is loaded. If the program is not loaded, attach the microcontroller to the devboard and connect with the PC. Open the project containing the correct code and simply press the "Build and Program" button in the IDE. This will open microProg and automatically begin programming the microcontroller. The development board will have a blue flashing light while the board is programming. When the programming is done, the blue light will cease flashing, and a red LED will blink on the main LED grid as a status that the program is running. \\
 \subsection{WRTNode}
 The WRTNode must have a power source. It came included with a split usb cable for mounting usb drives, and a second male connector to charge from a laptop. It also has the capabilities for being powered through a 3.3 Volt pin. Once turned on, in order to access the WRTNode's shell, you have to connect to its broadcasted SSID signal. Once connected, you can open a terminal and ssh into the node. If moving around often the WRTNode will need to reconfigure its up-router in order to get internet access.\\

 Once inside the shell of the node, you can do all sorts of things. For the scope of this project, you will run the ./mountUsb.sh script, which mounts the usb storing out server code. From there you will cd to the usb mounted at /mnt/shares. Inside the Usb's main folder should be another script called ./update.sh. This removes and old code and pulls down any new code from github. The reason for the usb was limited storage space on the WRTNode, and our Python server contained 4 libraries, one of which was hefty in size because of the asynchronous networking code. Another tool we use is virtual environments. This allows us to install any libraries to a separate folder so our main python install doesn't get crowded, and it is specific to this project only. If you are unable to see a "(vermeer)" before the beginning of every line in the console, then you are not correctly inside the virtual environment. In order to do so, type source vermeer/bin/activate. You should now be ready to operate the server.\\ 
 In order to run the code, make sure you are in the folder called vermeer-backend-master. Once inside execute python vermeer/backend/server\_asyncio.py. You can also execute this with a -debug flag for better testing purposes. The server will now wait until it gets a "Start" command from the CAN and PIC controller. Once started the server will always be listening on 192.168.1.1. However, you are only allowed to talk to it if you are connected to its broadcasted SSID as well, which you are allowed to make password protected. As soon as a client connects to it, it then goes through steps to determine whether to initialize the Virtual Terminal, or to update an existing one. It then parses an .iop file for specific components and constructs a json blob to send back the client to display the terminal. \\
 
 Any updates sent from the CAN through the PIC to the server, will also be sent out to all and any connected clients. The clients must react and update their displays and respond with either a success message or an error message. \\
 
 If any client disconnects at any time, whether on purpose or accident, the server will know about it and terminate the connection on its end as well, freeing up space and memory. \\

 \subsection{Android Device} 
 To operate the Android tablet we must first have it fully charged and turned on. As soon as it is on we have a couple of choices on how we plan to install the app. We can default to putting the app on the Google Play Store, which allows anybody in the given locales to download it. We can also use Google Community groups to allow only a select few from seeing it in the play store, but this is a hassle for any user needing to download it fast. Another option is through third party distributes such as TestFlight, which allows people to sign up via email to receive a download of the app. And finally we can simply install the .apk ourselves through manual transfer, whether by email or a download link from a website. \\

 As soon as the app is installed, open the app by clicking on it from the launcher or app drawer. Once signed in, the user is given one option, to start the Terminal. The app then runs a set of background tasks to pull down information from our WebSocket server. This will include all of the components from the .iop file such as output texts, input texts, pictures, graphics, charts, and commands. The android app then builds all of these using gson to convert the json blobs. It dynamically and manually constructs the views based on what was sent from the server. \\

 As soon as the UI is constructed the user now has free reign over the tablet in regards to any predefined program issued from the CAN and .iop. This includes clicking any buttons, inputting any information, and performing tasks. The android application is always listening to the WebSocket server through an open port that was established during the handshake procedure. This allows the server to update any ui components at any time of the duration of the app as well. \\

 Once a user is done using the app, they can safely turn off the terminal by selecting the disconnect button at the top. This is better than just turning off the screen or then pressing home or back, because it allows the server know that we wanted to safely disconnect and that it wasn't an error that occurred. \\

 \subsection{Summary} 
 Make sure the WRTNode is turned on and functional. Currently you will have to ssh into the server to start it manually given the steps above. In the future we would plan to create a startup script that runs on boot, that mounts our usb drive, runs the update script, and runs ther server. After the WRTNode is turned on and functionally, it will be waiting for the PIC to send it a  message. As soon as any CAN Controller is turned on (like our 605 Baler model) it should transmit a signal through its CAN interface to the PIC. The PIC will then send a "Start" signal to the server to turn let the server on the WRTNode know that the CAN and any Controllers are in use. The Android tablet can now connect by following the above steps and clicking the "Start" button on the device. \\


\section{Testing}
\subsection{CAN-UART Connection}
The CAN bus was tested using Vector VN 1630 hardware with varying CAN messages that were  controlled by CANalyzer software. The CAN-UART connection was first tested by sending the CAN messages to the UART connection that was connected to 	wifi to a computer. The received messages then, was verified to be the same as the send messages. \\

\subsection{Endurance Test}
The CAN-UART connection was run for more than 5 hours to see whether it can run for long hours and the messages is not leaking. The CAN messages kept sending the same messages for 5 hours and the received messages was checked to see if it remains the same for that 5 hours. \\

\subsection{Interference Test}
The CAN messages was then interfered with other different CAN messages sending to the same CAN bus. Only the desired messages was selected and sent to the android device. \\

\section{Design Revisions}
\subsection{Design Revision v1} 
Our original design featured a single XBee WiFi module. XBee WiFi modules offer either a UART or SPI interface to transfer data up to 6Mbps. We soon found early on that the XBee is easily connected to the android device but only through the cloud service. In our project we do not have access to the cloud with the current design.\\

\subsection{Design Revision v2} 
In design revision 2, we solved the problem of not being able to connect to the cloud by adding another XBee. XBees have the ability to connect and communicate with each other without the need for a cloud service. We also needed a way for this additional XBee module to communicate with the android device. This was accomplished using an Android IOIO (pronounced YO-YO). The android IOIO can connect to the Android Device using a USB plug, or connect via bluetooth. The android IOIO can then act as a pipe for the UART data from the XBee to the android device. \\

This revision has the possibility to be suitable in use cases other than the 605 baler. The baler is more specific in our case because of the VT. In some scenarios, it has been expressed that Vermeer may wish to just “dump information” to an android device. If simple data needs to be sent and there needs to be little parsing, that is, parsing that can feasibly be  done in a ‘C’ program directly on the microcontroller, this is a possible solution. The data can then be later transferred in other forms to a computer to execute more rigourus parsing and analyzation. In this case, the android device may simply act as a vessel to carry the data from the machine to a computer. The advantage of the XBee modules is the ability to network with multiple XBees. This way, multiple devices can receive the data at the same time. With the model of XBees that we selected, Vermeer has the ability to choose which antenna’s to add to the XBees based on the range and price required to do so. \\

\subsection{Design Revision v3} 
Up until this revision, we had been communicating with Vermeer to figure out how we would parse the IOP file in the same manner that the VT does. We decided that we wanted to do as much parsing of this data before transferring over WiFi to save processing power on the android device to reduce battery consumption. Vermeer had an early stage parser that was written in python. With the time constraints of the project we decided it would be more practical to attempt to implement and finish their partial parser, instead of creating a similar program in C. Using this program meant we could not use the PIC32 to handle the parsing of the IOP file. To run python we chose to use the WRT Node. The WRT node then received the IOP file from the PIC32, parsed it, and sent the data to the XBee modules. \\

\subsection{Design Revision v4} 
Design Revision 4 changes were made from Design Revision 3 because the WRT Node is able to directly communicate with the android device. Removing the XBee modules removes 3 modules, greatly reducing debugging, and places for things to go wrong. The USB port is available now that the android IOIO does not need to connect to communicate with the android device.\\

\section{Tools}
\textbf{Vector}\\
Vector is very useful tool for debugging with CAN busses. We used the vector VN1630. With the Vector hardware (along with CANalyzer software) traffic can be read on the CAN bus, as well as sent through the bus. Vector is capable of acting as two modules on the bus. This allowed us to easily conduct interference testing without additional tools. Although in early debugging we diagnosed problems with an oscilloscope, the Vector saved us days, even weeks, of debugging and manually reading/translating CAN signals.\\

\textbf{Development Board}\\
The development board used for this project was an LV-32MX v6 PIC32 Development System. We chose to use this mainly for the purpose of programming. Programming the PIC manually proved to have finicky voltage regulation and the chip burned. The opportunity cost of solving the programming problem was too great, and the use of a development board was chosen. This system is one generation out of date, but still available. Therefore, when ordering chips with breakout boards, it is important to match withe development board, as the breakout board pin layout differs greatly.\\

\textbf{MicroC/MicroProg}\\
MicroC is the IDE/Compiler used for the PIC32 microcontrollers. Like many embedded system IDE's the usability could be greatly improved. However, the program succeeded in it's intended purpose.\\
MicroProg is the program for uploading a new program to the micro-controller. Again, the usability could be slightly upgraded, but successfully accomplishes its goals.\\

\textbf{XCTU}\\
XCTU is an extremely helpful tool in debugging and testing XBee modules. It is also a simple way to reconfigure settings on the XBee modules such as the baud rate, SSID, and network type. XCTU is the most usable program that we used. Including a very intuitive user interface for receiving and sending data via the XBee modules.\\

\textbf{Slack (slack.com)}\\
Slack is a team communication platform. Much like email, or any other chat based platform, however it allows for some heavy customizations and multiple integrations. Any github commit, trello change, or google hangout, will show up in Slack. Slack allows for multiple channels, so a single feed isn't constantly getting clogged up as well. We used channels like \#Software, \#Hardware, and \#General.\\

\textbf{Trello (trello.com)}\\
Trello is free ticket management system. Trello allows you to make tickets with labels on them, we had labels such as “Hardware”, “Software”, “Documentation”, etc. Trello also allows for customized lists, we had a simple set of lists “TODO”, “In Progress”, and “Done”. Some helpful additional lists could be “In test” and “Ready for testing”.  Users can also be assigned to tickets (or multiple users) and comments can be made. A useful feature different than some other ticket management systems is the ability to add checklists inside of a single ticket, as opposed to making multiple tickets.\\

\textbf{Github (github.com)}\\
Github is a popular version control system. We used this for code on all of the modules. This proved to be very useful comparing code between revisions that worked and revisions that didn't. Github has also been useful for reviewing other member's code changes through pull requests and Github's diff tool.\\

\section{Setbacks/Challenges} 
The biggest setback we had during the project was communication. There were multiple times when lack of quality communication (sometimes out of our control) cost us a lot of development time. At the beginning of the project it took us longer than anticipated to fully understand the scope of our project. A day trip to Vermeer’s corporate headquarters meeting with our Vermeer contact and others helped alleviate this initial confusion. After the trip to Vermeer designing solutions emerged at a more rapid pace. Another instance where lack of quality communication stalled progress was on the software side. We knew that we would receive and IOP file and needed to parse it. Learning how to parse this IOP file proved to be much more difficult than anticipated, and many meetings with the incorrect people, pointing us to the “correct” people impeded software development greatly. \\

Another setback that we had early on in development was programming the microcontroller. When attempting to program the microcontroller manually, the voltage was not regulated and burned the chip. To avoid this from happening again, when we ordered another chip, we also ordered a development board to help in the programming process. \\

The third major setback that we had in development was getting the clocking to work so all the peripherals worked at the same time on the microcontroller. After strenuous debugging it was found that the phased-lock loop circuit was the culprit. After correcting this, development came along with few other major setbacks. \\

\section{Reflection}
This project has taught us many things. With the hardware side, it was the first time any of us had created a hardware project from nothing. Previously, we were given instructions, skeletons, and hardware, then we simply built on top of that. A lot was gained from making the project with nothing to start. We learned about comparing and researching hardware modules. From this alone we learned about numerous technologies that we had never even heard of before. This also gave us experience in figuring out design specs so that it is possible to find which hardware will work well in the project.\\

As in the courses learnt before, we always used a normal breadboard to build a functioning circuit with different components of resistors, capacitors, LED’s and operational amplifier. Through this project, we had built the circuit without really testing it to a permanent circuit board as it known as Printed Circuit Board(PCB). In this project, we had used the Eagle PCB design software. It is the first time, we had learnt to built a PCB as it is not thought in any specific courses. It is kind similar to a combination of pspice design software and layout design that we had learnt in two different courses. Attention to details of the different pins and not to overlap between two similar wires is really important to avoid short-circuits and failure of circuit to operate they way we want.\\

On the software side a lot of new tools were used, and a lot of strange behaviors were used. We knew the technology rather well. Android and python servers we were very familiar with. However, the way we used these tools were uncanny to say the least. With Android, layouts are predefined, and created during compile time that they might be viewed during runtime faster. Its just how the framework works. However to complete this project, we had to build the UI dynamically during runtime. We were worried this would affect runtimes and memory consumptions and management. On the server side, we tossed back and forth the idea of using full C code or python for the server. We ended up going with python because it was easier to implemented the type of server we wanted. However we learned interesting details when it came to parsing the .iop file such as how python packs bits into a struct. Our understanding of how an .iop file is created, and how it is read was challenged, but we now understand the overall process.\\

Even though it is well known and taught often, this project revealed even more so how important communication is. Slack greatly helped our internal communication channels. However, our communication channels with Vermeer lacked in comparison. This project showed us the importance of face-to-face communication. Our visit to Vermeer headquarters, and meeting in person at the Iowa State campus proved to be much more effective than phone calls, or even skype.\\

Our efficiency at reading data sheets has improved greatly over the course of the project. Before, in class, there was little need to look in data sheets, the needed data was often in the lab instructions. If we needed to look at a data sheet, where to look was usually pointed out to us. The autonomy of this project greatly improved our competency and efficiency in reading data sheets.\\

\section{Future Iterations}
A simple update to improve the system would be to upgrade the communications from UART to SPI. SPI requires an extra pin, but allows for faster data transmission. \\

For the WRT Node, Server robustness could be improved. Currently waiting for data from the UART is a blocking process. The system would be more efficient and robust if a non-blocking thread listened for UART communication. \\

On the Android UI, more VT elements need to be recognizable to complete a fully functional application. The current parsing of VT elements can be used as a template.\\

\end{document}
